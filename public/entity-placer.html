<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Entity Placer - Home Dashboard</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #1a1a2e;
      color: #fff;
      min-height: 100vh;
    }
    .container {
      display: flex;
      height: 100vh;
    }

    /* Sidebar */
    .sidebar {
      width: 320px;
      min-width: 320px;
      flex-shrink: 0;
      background: #16213e;
      padding: 15px;
      overflow-y: auto;
      border-right: 2px solid #4a6fa5;
    }
    .sidebar h2 {
      margin-bottom: 10px;
      font-size: 1.1rem;
      color: #4ade80;
    }
    .filter-bar {
      display: flex;
      gap: 6px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    .filter-btn {
      padding: 5px 10px;
      border: 1px solid #444;
      background: transparent;
      color: #888;
      border-radius: 15px;
      cursor: pointer;
      font-size: 0.75rem;
    }
    .filter-btn.active {
      background: #4a6fa5;
      border-color: #4a6fa5;
      color: #fff;
    }
    .search-box {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #333;
      background: #1a1a2e;
      color: #fff;
      border-radius: 8px;
      margin-bottom: 12px;
      font-size: 0.9rem;
    }
    .entity-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .entity-item {
      padding: 8px 10px;
      background: rgba(255,255,255,0.05);
      border-radius: 6px;
      cursor: grab;
      border: 1px solid transparent;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .entity-item:hover {
      background: rgba(255,255,255,0.1);
      border-color: #4a6fa5;
    }
    .entity-item.dragging {
      opacity: 0.5;
    }
    .entity-item.placed {
      opacity: 0.4;
      background: rgba(74, 222, 128, 0.1);
    }
    .entity-item .icon {
      font-size: 1.2rem;
      width: 28px;
      text-align: center;
    }
    .entity-item .info {
      flex: 1;
      min-width: 0;
    }
    .entity-item .name {
      font-size: 0.85rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .entity-item .meta {
      font-size: 0.7rem;
      color: #666;
    }

    /* Main area */
    .main-area {
      flex: 1;
      padding: 15px;
      display: flex;
      flex-direction: column;
    }
    .toolbar {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      align-items: center;
      flex-wrap: wrap;
    }
    .toolbar button {
      padding: 8px 16px;
      background: #4a6fa5;
      border: none;
      color: #fff;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
    }
    .toolbar button:hover {
      background: #5a7fb5;
    }
    .toolbar button.danger {
      background: #dc2626;
    }
    .toolbar button.danger:hover {
      background: #ef4444;
    }
    .toolbar .stats {
      margin-left: auto;
      color: #888;
      font-size: 0.85rem;
    }
    .save-status {
      color: #4ade80;
      font-size: 0.8rem;
      margin-left: 10px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .save-status.visible {
      opacity: 1;
    }

    /* Floor plan */
    .floor-plan-container {
      flex: 1;
      background: #0d0d1a;
      border-radius: 12px;
      position: relative;
      overflow: hidden;
    }
    .floor-plan-svg {
      width: 100%;
      height: 100%;
      background: #fff;
    }
    .room-rect {
      fill: rgba(100, 100, 120, 0.3);
      stroke: rgba(255,255,255,0.2);
      stroke-width: 0.3;
      transition: all 0.2s;
    }
    .room-rect:hover {
      fill: rgba(100, 100, 120, 0.5);
    }
    .room-label {
      fill: rgba(255,255,255,0.4);
      font-size: 2.5px;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
    }

    /* Placed entity icons - hit area */
    .icon-hitarea {
      fill: transparent;
      cursor: move;
    }
    .icon-hitarea:hover + .icon-emoji {
      filter: brightness(1.3);
    }
    .icon-group.selected .icon-hitarea {
      fill: rgba(74, 222, 128, 0.2);
      stroke: #4ade80;
      stroke-width: 2;
    }

    /* Tooltip */
    .tooltip {
      position: fixed;
      background: #1e1e2e;
      border: 1px solid #4a6fa5;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.8rem;
      pointer-events: none;
      z-index: 1000;
      max-width: 250px;
    }
    .tooltip .name {
      font-weight: 500;
      margin-bottom: 4px;
    }
    .tooltip .id {
      color: #888;
      font-size: 0.7rem;
    }

    /* Delete zone */
    .delete-zone {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 30px;
      background: rgba(220, 38, 38, 0.8);
      border-radius: 8px;
      font-size: 0.9rem;
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;
    }
    .delete-zone.visible {
      opacity: 1;
      pointer-events: auto;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="sidebar">
      <h2>Entities</h2>
      <div class="filter-bar">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="light">üí°</button>
        <button class="filter-btn" data-filter="switch">üîå</button>
        <button class="filter-btn" data-filter="fan">üåÄ</button>
        <button class="filter-btn" data-filter="sensor">üìä</button>
        <button class="filter-btn" data-filter="binary_sensor">üëÅ</button>
        <button class="filter-btn" data-filter="climate">üå°</button>
        <button class="filter-btn" data-filter="media_player">üì∫</button>
        <button class="filter-btn" data-filter="camera">üì∑</button>
      </div>
      <input type="text" class="search-box" placeholder="Search entities..." id="searchBox">
      <div class="entity-list" id="entityList">
        <div style="color:#888; padding:20px; text-align:center;">Loading entities...</div>
      </div>
    </div>

    <div class="main-area">
      <div class="toolbar">
        <button onclick="saveNow()" id="saveBtn">üíæ Save</button>
        <button onclick="exportConfig()">üì§ Export</button>
        <button onclick="loadConfig()">üìÇ Load</button>
        <button class="danger" onclick="clearAll()">üóë Clear</button>
        <input type="file" id="fileInput" style="display:none" accept=".json">
        <span class="stats" id="stats">0 placed</span>
        <span class="save-status" id="saveStatus"></span>
      </div>

      <div class="floor-plan-container" id="floorPlan">
        <svg viewBox="0 0 100 150.75" class="floor-plan-svg" id="floorPlanSvg" preserveAspectRatio="xMidYMid meet"></svg>
        <div class="delete-zone" id="deleteZone">üóë Drop here to remove</div>
      </div>
    </div>
  </div>

  <div class="tooltip" id="tooltip" style="display:none;"></div>

  <script>
    // Icon mapping by domain
    const ICONS = {
      light: 'üí°',
      switch: 'üîå',
      fan: 'üåÄ',
      sensor: 'üìä',
      binary_sensor: 'üëÅ',
      climate: 'üå°',
      media_player: 'üì∫',
      camera: 'üì∑',
      cover: 'üö™',
      lock: 'üîí',
      vacuum: 'ü§ñ',
      person: 'üë§',
      device_tracker: 'üìç',
      automation: '‚öôÔ∏è',
      script: 'üìú',
      scene: 'üé¨',
      input_boolean: '‚úì',
      input_number: 'üî¢',
      input_select: 'üìã',
      button: 'üîò',
      number: 'üî¢',
      select: 'üìã',
      update: 'üîÑ',
      weather: '‚òÅÔ∏è',
      sun: '‚òÄÔ∏è',
      zone: 'üìç',
      water_heater: 'üöø',
      humidifier: 'üí®',
      alarm_control_panel: 'üö®',
      remote: 'üì±',
      siren: 'üîî',
      default: '‚óè'
    };

    // Room layout
    const ROOMS = [
      { id: "master_bath", name: "Master Bath", x: 2, y: 2, w: 14, h: 14 },
      { id: "master", name: "Master Bed", x: 16, y: 2, w: 18, h: 14 },
      { id: "bedroom", name: "Sean Room", x: 68, y: 2, w: 30, h: 18 },
      { id: "living_room", name: "Living Room", x: 34, y: 2, w: 34, h: 32 },
      { id: "bathroom", name: "Sean Bath", x: 80, y: 20, w: 18, h: 14 },
      { id: "game_room", name: "Game Room", x: 2, y: 16, w: 28, h: 18 },
      { id: "dining", name: "Dining", x: 2, y: 34, w: 32, h: 16 },
      { id: "kitchen", name: "Kitchen", x: 34, y: 34, w: 18, h: 16 },
      { id: "breakfast", name: "Breakfast", x: 52, y: 34, w: 20, h: 16 },
      { id: "nursery", name: "Nursery", x: 2, y: 50, w: 22, h: 18 },
      { id: "nursery_bath", name: "Nursery Bath", x: 2, y: 68, w: 14, h: 16 },
      { id: "laundry", name: "Laundry", x: 34, y: 50, w: 18, h: 16 },
      { id: "mudroom", name: "Mudroom", x: 52, y: 50, w: 18, h: 16 },
      { id: "lab", name: "Lab", x: 70, y: 50, w: 28, h: 16 },
      { id: "guest_room", name: "Guest Bed", x: 16, y: 68, w: 18, h: 16 },
      { id: "entry", name: "Entry", x: 34, y: 68, w: 10, h: 16 },
      { id: "office", name: "Office", x: 44, y: 66, w: 20, h: 18 },
      { id: "garage", name: "Garage", x: 64, y: 66, w: 34, h: 18 },
    ];

    // Constants
    const ICON_SIZE_PX = 24; // Desired icon size in screen pixels
    const VIEWBOX_WIDTH = 100;
    const VIEWBOX_HEIGHT = 150.75; // Matches house.jpg aspect ratio (995x1500)
    const FLOOR_PLAN_IMAGE = '/house.jpg';

    let entities = [];
    let placements = {}; // { entityId: { x, y } }
    let currentFilter = 'all';
    let draggedEntityId = null;
    let draggedPlacedId = null;
    let selectedEntityId = null;
    let currentScale = 1;

    const svg = document.getElementById('floorPlanSvg');
    const tooltip = document.getElementById('tooltip');
    const deleteZone = document.getElementById('deleteZone');

    function getIcon(domain) {
      return ICONS[domain] || ICONS.default;
    }

    // Compute current scale (screen pixels per SVG unit)
    function updateScale() {
      const rect = svg.getBoundingClientRect();
      const scaleX = rect.width / VIEWBOX_WIDTH;
      const scaleY = rect.height / VIEWBOX_HEIGHT;
      currentScale = Math.min(scaleX, scaleY); // preserveAspectRatio="meet"
      renderPlacedIcons();
    }

    // Convert screen coords to SVG coords
    function screenToSVG(screenX, screenY) {
      const pt = svg.createSVGPoint();
      pt.x = screenX;
      pt.y = screenY;
      const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
      return { x: svgP.x, y: svgP.y };
    }

    // Load CSV data
    async function loadEntities() {
      try {
        const response = await fetch('/entities_v2.csv');
        if (!response.ok) throw new Error('HTTP ' + response.status);
        const text = await response.text();
        const lines = text.trim().split('\n');
        const headers = lines[0].split(',');

        entities = lines.slice(1).map(line => {
          const values = line.match(/(".*?"|[^,]+)/g) || [];
          const obj = {};
          headers.forEach((h, i) => {
            obj[h] = (values[i] || '').replace(/^"|"$/g, '');
          });
          return obj;
        }).filter(e => e.suggested_usage !== 'remove');

        console.log('Loaded', entities.length, 'entities');
        renderEntityList();
      } catch (err) {
        console.error('Failed to load entities:', err);
        document.getElementById('entityList').innerHTML =
          '<p style="color:#f88; padding:15px;">Failed to load entities_v2.csv</p>';
      }
    }

    function renderEntityList() {
      const searchTerm = document.getElementById('searchBox').value.toLowerCase();
      const list = document.getElementById('entityList');

      const filtered = entities.filter(e => {
        if (currentFilter !== 'all' && e.domain !== currentFilter) return false;
        if (searchTerm && !e.friendly_name.toLowerCase().includes(searchTerm) &&
            !e.entity_id.toLowerCase().includes(searchTerm)) return false;
        return true;
      });

      list.innerHTML = filtered.map(e => {
        const isPlaced = placements[e.entity_id];
        return `
          <div class="entity-item ${isPlaced ? 'placed' : ''}"
               draggable="true"
               data-entity-id="${e.entity_id}"
               title="${e.entity_id}">
            <span class="icon">${getIcon(e.domain)}</span>
            <div class="info">
              <div class="name">${e.friendly_name || e.entity_id}</div>
              <div class="meta">${e.domain}${isPlaced ? ' ‚úì' : ''}</div>
            </div>
          </div>
        `;
      }).join('');

      // Add drag handlers
      list.querySelectorAll('.entity-item').forEach(item => {
        item.addEventListener('dragstart', onDragStart);
        item.addEventListener('dragend', onDragEnd);
      });
    }

    function renderFloorPlan() {
      // Render floor plan image
      const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
      image.setAttribute('href', FLOOR_PLAN_IMAGE);
      image.setAttribute('x', '0');
      image.setAttribute('y', '0');
      image.setAttribute('width', VIEWBOX_WIDTH);
      image.setAttribute('height', VIEWBOX_HEIGHT);
      image.setAttribute('preserveAspectRatio', 'xMidYMid slice');

      // Icons layer (will be updated separately)
      const iconsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      iconsGroup.id = 'icons-layer';

      svg.innerHTML = '';
      svg.appendChild(image);
      svg.appendChild(iconsGroup);

      renderPlacedIcons();
      updateStats();
    }

    function renderPlacedIcons() {
      const iconsLayer = document.getElementById('icons-layer');
      if (!iconsLayer) return;

      iconsLayer.innerHTML = '';

      // Calculate inverse scale for constant-size icons
      const inverseScale = 1 / currentScale;
      const iconSizeInSvgUnits = ICON_SIZE_PX * inverseScale;
      const hitAreaSize = iconSizeInSvgUnits * 1.2;

      for (const [entityId, pos] of Object.entries(placements)) {
        const entity = entities.find(e => e.entity_id === entityId);
        if (!entity) continue;

        const icon = getIcon(entity.domain);
        const isSelected = selectedEntityId === entityId;

        // Create group for icon
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.classList.add('icon-group');
        if (isSelected) g.classList.add('selected');
        g.dataset.entityId = entityId;
        g.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);

        // Hit area (circle) - scaled inversely
        const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        hitArea.classList.add('icon-hitarea');
        hitArea.setAttribute('cx', 0);
        hitArea.setAttribute('cy', 0);
        hitArea.setAttribute('r', hitAreaSize / 2);

        // Icon text - with inverse scale transform
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.classList.add('icon-emoji');
        text.setAttribute('x', 0);
        text.setAttribute('y', 0);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('dominant-baseline', 'central');
        text.setAttribute('font-size', iconSizeInSvgUnits);
        text.setAttribute('pointer-events', 'none');
        text.textContent = icon;

        g.appendChild(hitArea);
        g.appendChild(text);
        iconsLayer.appendChild(g);

        // Event handlers
        hitArea.addEventListener('mousedown', onPlacedIconMouseDown);
        hitArea.addEventListener('mouseenter', showTooltip);
        hitArea.addEventListener('mouseleave', hideTooltip);
      }
    }

    function onDragStart(e) {
      draggedEntityId = e.target.closest('.entity-item').dataset.entityId;
      e.target.closest('.entity-item').classList.add('dragging');
      e.dataTransfer.effectAllowed = 'copy';
    }

    function onDragEnd(e) {
      e.target.closest('.entity-item').classList.remove('dragging');
      draggedEntityId = null;
      deleteZone.classList.remove('visible');
    }

    // Handle drop on SVG
    svg.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
    });

    svg.addEventListener('drop', (e) => {
      e.preventDefault();
      if (!draggedEntityId) return;

      const coords = screenToSVG(e.clientX, e.clientY);

      // Clamp to viewBox
      coords.x = Math.max(1, Math.min(VIEWBOX_WIDTH - 1, coords.x));
      coords.y = Math.max(1, Math.min(VIEWBOX_HEIGHT - 1, coords.y));

      placements[draggedEntityId] = { x: coords.x, y: coords.y };
      renderPlacedIcons();
      renderEntityList();
      updateStats();
      autoSave();
      draggedEntityId = null;
    });

    // Handle dragging placed icons
    let isDraggingPlaced = false;
    let dragOffset = { x: 0, y: 0 };

    function onPlacedIconMouseDown(e) {
      e.preventDefault();
      const group = e.target.closest('.icon-group');
      const entityId = group.dataset.entityId;
      draggedPlacedId = entityId;
      selectedEntityId = entityId;
      isDraggingPlaced = true;
      deleteZone.classList.add('visible');

      const pos = placements[entityId];
      const screenPos = screenToSVG(e.clientX, e.clientY);
      dragOffset.x = pos.x - screenPos.x;
      dragOffset.y = pos.y - screenPos.y;

      renderPlacedIcons();
    }

    document.addEventListener('mousemove', (e) => {
      if (!isDraggingPlaced || !draggedPlacedId) return;

      const coords = screenToSVG(e.clientX, e.clientY);
      coords.x = Math.max(1, Math.min(VIEWBOX_WIDTH - 1, coords.x + dragOffset.x));
      coords.y = Math.max(1, Math.min(VIEWBOX_HEIGHT - 1, coords.y + dragOffset.y));

      placements[draggedPlacedId] = { x: coords.x, y: coords.y };

      // Update icon position directly
      const group = document.querySelector(`.icon-group[data-entity-id="${draggedPlacedId}"]`);
      if (group) {
        group.setAttribute('transform', `translate(${coords.x}, ${coords.y})`);
      }

      // Check if over delete zone
      const deleteRect = deleteZone.getBoundingClientRect();
      if (e.clientX >= deleteRect.left && e.clientX <= deleteRect.right &&
          e.clientY >= deleteRect.top && e.clientY <= deleteRect.bottom) {
        deleteZone.style.background = 'rgba(239, 68, 68, 1)';
      } else {
        deleteZone.style.background = 'rgba(220, 38, 38, 0.8)';
      }
    });

    document.addEventListener('mouseup', (e) => {
      if (!isDraggingPlaced) return;

      // Check if dropped on delete zone
      const deleteRect = deleteZone.getBoundingClientRect();
      if (e.clientX >= deleteRect.left && e.clientX <= deleteRect.right &&
          e.clientY >= deleteRect.top && e.clientY <= deleteRect.bottom) {
        delete placements[draggedPlacedId];
        renderEntityList();
      }

      isDraggingPlaced = false;
      draggedPlacedId = null;
      deleteZone.classList.remove('visible');
      deleteZone.style.background = '';
      renderPlacedIcons();
      updateStats();
      autoSave();
    });

    // Tooltip
    function showTooltip(e) {
      const group = e.target.closest('.icon-group');
      const entityId = group.dataset.entityId;
      const entity = entities.find(en => en.entity_id === entityId);
      if (!entity) return;

      tooltip.innerHTML = `
        <div class="name">${entity.friendly_name}</div>
        <div class="id">${entity.entity_id}</div>
      `;
      tooltip.style.display = 'block';
      tooltip.style.left = (e.clientX + 15) + 'px';
      tooltip.style.top = (e.clientY + 15) + 'px';
    }

    function hideTooltip() {
      tooltip.style.display = 'none';
    }

    // Click on SVG background to deselect
    svg.addEventListener('click', (e) => {
      if (e.target.tagName === 'svg' || e.target.tagName === 'image') {
        selectedEntityId = null;
        renderPlacedIcons();
      }
    });

    // Delete selected with keyboard
    document.addEventListener('keydown', (e) => {
      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedEntityId) {
        e.preventDefault();
        delete placements[selectedEntityId];
        selectedEntityId = null;
        renderPlacedIcons();
        renderEntityList();
        updateStats();
        autoSave();
      }
    });

    function updateStats() {
      const count = Object.keys(placements).length;
      document.getElementById('stats').textContent = `${count} placed`;
    }

    // Auto-save to localStorage
    const STORAGE_KEY = 'entity-placements';

    function saveToStorage() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(placements));
    }

    function loadFromStorage() {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        try {
          placements = JSON.parse(saved);
          return true;
        } catch (e) {
          console.error('Failed to parse saved placements:', e);
        }
      }
      return false;
    }

    function showSaveStatus(msg) {
      const status = document.getElementById('saveStatus');
      status.textContent = msg;
      status.classList.add('visible');
      setTimeout(() => status.classList.remove('visible'), 2000);
    }

    function saveNow() {
      saveToStorage();
      showSaveStatus('‚úì Saved');
    }

    // Auto-save on any placement change
    function autoSave() {
      saveToStorage();
    }

    function exportConfig() {
      const config = {
        version: 2,
        placements: placements,
        entities: Object.keys(placements).map(id => {
          const entity = entities.find(e => e.entity_id === id);
          const pos = placements[id];
          return {
            entity_id: id,
            friendly_name: entity?.friendly_name || id,
            domain: entity?.domain,
            x: Math.round(pos.x * 100) / 100,
            y: Math.round(pos.y * 100) / 100
          };
        })
      };

      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'entity-placements.json';
      a.click();
      URL.revokeObjectURL(url);
    }

    function loadConfig() {
      document.getElementById('fileInput').click();
    }

    document.getElementById('fileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const config = JSON.parse(e.target.result);
            placements = config.placements || {};
            renderPlacedIcons();
            renderEntityList();
            updateStats();
            autoSave();
            showSaveStatus('‚úì Loaded');
          } catch (err) {
            alert('Invalid config file');
          }
        };
        reader.readAsText(file);
      }
    });

    function clearAll() {
      if (confirm('Clear all placements?')) {
        placements = {};
        selectedEntityId = null;
        renderPlacedIcons();
        renderEntityList();
        updateStats();
        autoSave();
      }
    }

    // Filter buttons
    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentFilter = btn.dataset.filter;
        renderEntityList();
      });
    });

    // Search
    document.getElementById('searchBox').addEventListener('input', renderEntityList);

    // ResizeObserver to update scale when container resizes
    const resizeObserver = new ResizeObserver(() => {
      updateScale();
    });
    resizeObserver.observe(svg);

    // Initialize
    loadFromStorage(); // Load saved placements first
    loadEntities();
    renderFloorPlan();
    // Initial scale calculation after a brief delay for layout
    requestAnimationFrame(() => {
      updateScale();
    });
  </script>
</body>
</html>
